# [인프런] 따라하며 배우는 도커와 CI환경

- 섹션 2. 도커 기본
    
    ### 도커를 쓰는 이유
    
    - 프로그램을 다운 받을 때 다운 받는 환경(서버, 패키지 버전, OS 등)에 따라 과정이 복잡해지고, 달라진다.
    - 설치 과정의 복잡함을 해결하기 위해 도커를 사용하게 된다.
    
    ### 도커란 무엇인가?
    
    - **컨테이너**를 이용하여 응용프로그램을 더 쉽게 만들고, 배포하고, 실행할 수 있도록 설계된 도구이며 컨테이너 기반의 오픈소스 가상화 플랫폼이며 생태계
        - 컨테이너란?
            - 컨테이너 안에 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포와 관리를 단순하게 해준다.
    
    ### 도커 이미지와 도커 컨테이너 정의
    
    - 컨테이너
        - 코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위
    - 컨테이너 이미지
        - 프로그램을 실행하는 데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지
        - 이미지의 인스턴스 == 컨테이너
        - 런타임에 컨테이너가 됨
    
    ### 도커를 사용할 때의 흐름
    
    - docker client → docker server
        1. 도커 CLI에 커맨드 입력
        2. 도커 서버(Daemon)가 커맨드를 받아서 작업 실행
    - docker run hello-world를 입력했을 때
        1. 도커 CLI에 커맨드 입력하면 클라이언트에서 서버로 요청 전송
        2. 서버는 hello-world 이미지가 cache 되어 있는지 확인
            
            2-1. 없으면, Docker hub에서 pull하고 caching
            
            2-2. 있으면, 3으로
            
        3. 이미지를 이용해서 컨테이너 생성
        4. 컨테이너는 프로그램 실행
    
    ### **도커와 기존의 가상화 기술과의 차이를 통한 컨테이너 이해**
    
    - 가상화 기술이 나오기 전
        - 한 대의 서버를 하나의 용도로
        - 남는 서버 공간 방치
        - 하나의 서버에 하나의 OS, 하나의 프로그램
        - 안정적, 비효율적
    - 하이퍼 바이저 기반의 가상화 출현
        - 논리적으로 공간을 분리하여 VM이라는 독립적인 가상 환경 서버 이용
        - 하이퍼 바이저
            - 호스트 시스템에서 다수의 게스트 OS 구동
            - 하드웨어와 각각의 VM을 모니터링
    - 하이퍼 바이저 기반의 VM 구조
        - 코어를 VM 당 하나씩 할당 (독립적)
        - 논리적으로 분리되어서 한 VM에 오류가 발생해도 다른 VM으로 퍼지지 않음
    - 도커 vs VM
        - 공통점
            - 기본 하드웨어에서 격리된 환경 내에 어플리케이션을 배치하는 방법
        - 차이점
            - 컨테이너는 하이퍼바이저와 게스트 OS가 필요하지 않아서 가벼움
            - 어플리케이션 실행 시
                - 컨테이너는 호스트 OS 위에 이미지를 배포하면 됨
                - VM은 VM을 띄우고 자원을 할당한 후 게스트 OS 부팅하여 어플리케이션 실행
                
                → VM이 복잡하고 무거움
                
    - 도커 컨테이너 격리 방법
        - 프로세스 사이에 벽을 만드는 리눅스 커널 기능
            - C Group
                - 프로세스 그룹의 리소스 사용량을 관리
            - 네임스페이스
                - 하나의 시스템에서 프로세스를 격리시키는 가상화 기술
    
    ### 이미지로 컨테이너 만들기
    
    - 이미지는 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하고 있다.
        - 실행 명령어
        - 파일 스냅샷
    - 이미지로 컨테이너 만드는 순서
        1. 도커 클리이언트에 명령어 입력
        2. 도커 이미지에 있는 파일 스냄샷을 컨테이너 하드디스크에 이동
        3. 이미지가 가지고 있는 명령어를 이용해서 파일 실행
    
    ### **C-group, 네임스페이스를 도커 환경에서 쓸 수 있는 이유**
    
    - docker version을 치면 서버가 linux로 되어 있음
    - 실제로 도커와 내 컴퓨터 사이에 리눅스가 있음
        - 리눅스 명령어를 사용할 수 있게 되는 것
- 섹션 3. 기본적인 도커 클라이언트 명령어 알아보기
    
    ### 도커 이미지 내부 파일 구조 보기
    
    - docker run 이미지이름 ls
        - docker: 도커 클라이언트 언급
        - run: 컨테이너 생성 및 실행
        - 이미지 이름: 이 컨테이너를 위한 이미지
        - ls
            - 이 자리는 원래 이미지가 가지고 있는 시작 명령어를 무시하고 여기에 있는 커맨드를 실행하게 함
            - ls 커맨드는 현재 디렉토리의 파일 리스트 표출
            - 주의: 이미지 파일 스냅샷에 명령어를 사용 가능하게 하는 파일이 있어야 실행 가능
    
    ### 컨테이너들 나열하기
    
    - docker ps(process status)
    - 이미지 설명
        - CONTAINER ID
            - 컨테이너의 고유한 아이디 hash값
        - IMAGE
            - 도커 이미지
        - COMMAND
            - 컨테이너 시작 시 실행될 명령어 (대부분 이미지에 내장)
        - CREATED
            - 컨테이너 생성 시간
        - STATUS
            - 컨테이너 상태
                - 실행중 Up, 종료 Exited, 일시정지 Pause
        - PORTS
            - 컨테이너가 개발한 포트와 호스트에 연결한 포트
        - NAMES
            - 고유한 이름
            - —name으로 이름 설정하지 않으면 도커 엔진이 임의로 설정
            - 중복 안되고 docker rename original changed로 변경 가능
    - docker ps -a
        - 꺼져있는 컨테이너까지 모두 보여줌
    
    ### 도커 컨테이너의 생명주기
    
    - 생명 주기
        - create - start - running - stopped - deleted
    - docker run image
        - docker create image
            - 이미지에 있는 파일 스냅샷을 하드디스크에 옮겨줌
        - docker start container
            - 실행 명령어를 옮겨서 실제 실행
    
    ### **Docker Stop vs Docker Kill**
    
    - 공통점
        - 모두 컨테이너를 중지
    - 차이점
        - Stop: Gracefully하게 중지 (진행중이던 작업 완료하고 정지)
        - Kill: 기다리지 않고 바로 중지
    
    ### 컨테이너 삭제하기
    
    - docker rm id/name
    - 중지를 먼저 해야 삭제 가능
    - 모든 컨테이너 삭제
        - docker rm ‘docker ps -a -q’
    - 이미지 삭제
        - docker rmi id
    - 컨테이너, 이미지, 네트워크 모두 삭제
        - docker system prune
    
    ### 실행 중인 컨테이너에 명령어 전달
    
    - docker exec id 명령어
    - docker run vs docker exec
        - run은 컨테이너를 만들어서 실행
        - exec은 실행중인 컨테이너에 명령어 전달
    
    ### **레디스를 이용한 컨테이너 이해**
    
    - docker run redis
    - redis-cli 입력 시, 컨테이너 외부에서 명령어를 실행한 것이기 때문에 connection refused 발생
        - 컨테이너 내부에서 명령어를 실행하기 위해 exec 사용
        - docker exec -it id redis-cli
        
        > git bash에서 winpty 문제 발생 시 맨 앞에 winpty 입력
        > 
        - -it 옵션: 명령어를 실행한 후 계속 명령어를 적을 수 있게 해준다.
            - interactive + terminal
    
    ### **실행 중인 컨테이너에서 터미널 생활 즐기기**
    
    - 기존에는 컨테이너에 명령어를 전달할 때 모든 명령어를 다 입력해야 했음 (docker exec...)
    - 문제를 해결하기 위해 쉘이나 터미널 환경으로 접속할 수 있음
    - 마지막 명령어로 sh 입력
        - 접속 후에는 실행하고자 하는 명령어만 입력하면 됨
    - ctrl+d로 빠져나오기
- 섹션 4. 직접 도커 이미지를 만들어 보기
    
    ### 도커 이미지 생성하는 순서
    
    - Dockerfile 작성 - 도커 클라이언트에 전달 - 도커 서버에서 작업 - 이미지 생성
    
    ### Dockerfile 만들기
    
    - Dockerfile이란
        - 도커 이미지를 만들기 위한 설정 파일
        - 컨테이너가 어떻게 행동해야 하는지에 대한 설정을 정의
    - 도커 파일 만드는 순서
        1. 베이스 이미지를 명시해준다. (파일 스냅샷에 해당) - 어떤 OS 쓰는지?
        2. 추가적으로 필요한 파일을 다운 받기 위한 명령어를 명시해준다. (파일 스냅샷에 해당)
        3. 컨테이너 시작 시 실행 될 명령어를 명시해준다. (시작 시 실행 될 명령어에 해당)
        - 베이스 이미지란
            - 도커 이미지는 여러 레이어로 구성
            - 베이스 이미지는 이 이미지의 기반이 되는 부분 (OS라고 생각)
    - FROM
        - 이미지 생성 시 기반이 되는 이미지 레이어
        - 이미지 이름: 태그 형식
    - RUN
        - 도커 이미지가 생성 되기 전에 수행할 쉘 명령어
    - CMD
        - 컨테이너가 시작되었을 때 실행할 실행 파일 또는 쉘 스크립트
        - 1회만 사용
    
    ### 도커 파일로 도커 이미지 만들기
    
    - docker build ./ or .
        - 도커 파일에 입력된 것들이 도커 클라이언트에 전달되어서 도커 서버가 인식하게 함
        1. 이미지 가져옴
        2. 임시 컨테이너 생성
            - 하드디스크에 파일 스냅샷 추가
        3. 임시 컨테이너 완성
        4. 임시 컨테이너로 이미지 생성
        5. 임시 컨테이너 삭제
    
    ### 내가 만든 이미지 기억하기 쉬운 이름 주기
    
    - docker run id를 통해 실행을 할 수 있지만 기억하기 힘든 id를 알고 있어야 한다는 단점이 있음
    - 이름을 주는 커맨드
        - docker build -t name
        - naming
            - {나의 도커 아이디}/{저장소, 프로젝트 이름}:{버전}
- 섹션 5. 도커를 이용한 간단한 Node.js 어플 만들기